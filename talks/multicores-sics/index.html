---
layout: presentation
title: "Programming Multicores in Scala"
date: "2017-11-28"
---

<section>
    <h3>Programming Mutlicores in Scala</h3>
    <h1>Past, Present, Future</h1>
    <h3>Felix Mulder</p>
</section>

<section>
    <img class="no-bg" src="klarna.svg" width="250"/>
</section>

<section>
    <img class="no-bg" src="epfl.svg" width="250"/>

    <aside class="notes">
        <ul>
            <li>Compiler engineer & release manager</li>
            <li>Big picture</li>
            <li>Pull in the same dir</li>
            <li>Get us on to a release schedule</li>
        </ul>
    </aside>
</section>

<section>
    <ul style="text-transform: uppercase; list-style-type:none">
        <li>
            <i class="fa fa-twitter"></i><i class="fa fa-github"></i> felixmulder
        </li>
        <li>
            <i class="fa fa-home" style="opacity: 0"></i><i class="fa fa-home"></i> <a href="http://felixmulder.com"> felixmulder.com</a>
        </li>

    <aside class="notes">
        I'm felixmulder on most social media, further contact info is available
        on my website.
    </aside>
</section>

<section>
    <h1>So, why scala?</h1>
</section>

<section>
    <h1 class="fragment">Types</h1>
    <h1 class="fragment">Types</h1>
    <h1 class="fragment">Types</h1>

    <aside class="notes">
        The three reasons!
    </aside>
</section>

<section>
    <pre><code class="scala">val x = 1<span class="fragment"> // x: Int</span>
</code></pre>
    <aside class="notes">
        type-inference, statically typed
    </aside>
</section>

<section>
    <pre><code class="scala">def foo[A](a: A): a.type = a</code></pre>
</section>

<section>
    <pre><code class="scala">trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}</code></pre>
</section>

<section>
    <pre><code class="scala">implicit val ListFunctor = new Functor[List] {
  def map[A, B](fa: List[A])(f: A => B): List[B] = fa.map(f)
}

def compose[F[_]: Functor, A, B, C](fa: F[A])(f: B => C, g: A => B) =
  F.map(fa)(f compose g)</code></pre>

    <aside class="notes">
        <ul>
            <li>With the notion of implicits</li>
            <li>model type classes</li>
            <li>ad-hoc polymorphism</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Make illegal state unrepresentable</h2>
</section>

<section>
    <h2>Finite State Machine</h2>
    <img class="no-bg" src="./on-off.png">

</section>
<section>
    <pre><code class="scala">trait State {
  type NewState <: State
  type Transition
}
<span class="fragment">
case class TurnOn()
case class TurnOff()

case object On {
  type Transition = TurnOn
  type NewState = Off
}</span>
<span class="fragment">
case object Off {
  type Transition = TurnOff
  type NewState = On
}
</span>
</code></pre>
</section>

<section>
    <pre><code class="scala">
def trans[S <: State](data: S#Transition, target: S#NewState): S#NewState =
  target
<span class="fragment">
def trans[S <: State](target: S#NewState)
                     (implicit ev: S#Transition =:= Nothing): S#NewState =
  target</span>
</code></pre>
</section>

<section>
    <h1>The big picture</h1>
    <ul>
        <li class="fragment">Correct</li>
        <li class="fragment">Scalable</li>
        <li class="fragment">Fast</li>
    </ul>

    <aside class="notes">
        The big picture AT KLARNA.

        Scalable =:= maintainable

        Choice of language heavily impacts this, static types
    </aside>
</section>

<section>
    <ul>
        <li>Actors</li>
        <li>Futures and friends</li>
        <li>Distributed programming models</li>
    </ul>
</section>

<section>
    <h1>Actors</h1>
    <pre><code class="scala">class MyActor extends Actor {
  def receive = {
    case "ping" => sender ! "pong"
  }
}
</code></pre>
    <aside class="notes">
    </aside>
</section>

<section>
    <h1>Actors</h1>
    <h2>Pros</h2>
    <ul>
        <li>Cheap</li>
        <li>Easy to bootstrap</li>
        <li>Akka</li>
    </ul>
    <aside class="notes">
        Receive function is synchronous

        Akka provides excellent tooling, there's advanced monitoring, lightbend
        etc
    </aside>
</section>

<section>
    <h1>Actors</h1>
    <h2>Cons?</h2>

    <h1 class="fragment" style="color: red;">Untyped üò∞</h1>
</section>

<section>
    <pre><code class="scala">
case class StartPong(ref: ActorRef)

class Pinger extends Actor {
  def receive = {
    case StartPong(ref) => ref ! "ping"
    case "pong"         => sender ! "ping"
  }
}

class Ponger extends Actor {
  def receive = {
    case "ping" => sender ! Expletive.random
  }
}
</code></pre>
</section>

<section>
<pre>
[<span style="color: red;">error</span>] scala.MatchError: Expletive(@#!$) (of class Expletive)
  ... 36 elided
</pre>
<div class="fragment">üò°</div>
</section>

<section>
    <pre><code class="scala">def receive: PartialFunction[Any, Unit]</code></pre>
    <h1 class="fragment">ü§¶‚Äç‚ôÇÔ∏è</h1>
</section>

<section>
    <h1>Can we remedy this?</h1>
</section>

<section>
    <pre><code class="scala">
case class StartPong(ref: ActorRef)


class Pinger extends Actor {
  def receive = {
    case StartPong(ref) => ref ! "ping"
    case "pong"         => sender ! "ping"
  }
}
                                                                   
class Ponger extends Actor {
  def receive = {
    case "ping" => sender ! Expletive.random
  }
}
</code></pre>
</section>

<section>
    <pre><code class="scala">
case class Pong(ref: TypedActorRef[Ping])
case class Ping(ref: TypedActorRef[Pong])

class Pinger extends TypedActor[Pong] {
  def receive = {
    case Pong(ref) => sender ! Ping(self)
  }
}

class Ponger extends TypedActor[Ping] {
  def receive = {
    case Ping(ref) => sender ! Expletive.random // still compiles üò∞
  }
}
</code></pre>
</section>

<section>
    <pre><code class="scala">
case class Pong(ref: TypedActorRef[Ping])
case class Ping(ref: TypedActorRef[Pong])

class Pinger extends TypedActor[Pong] {
  def receive = {
    case Pong(ref) => ref ! Ping(self)
  }
}

class Ponger extends TypedActor[Ping] {
  def receive = {
    case Ping(ref) => ref ! Expletive.random // doesn't compile! üò¨ 
  }
}
</code></pre>
</section>

<section>
    <h1>akka-typed</h1>
    <aside class="notes">
        <ul>
            <li>Still exeprimental</li>
            <li>Mixing typed and untyped?</li>
            <li>Runtime is still inherently untyped - has to match typed actor messages to their actors somehow</li>
        </ul>
    </aside>
</section>

<section>
    <h1>Future[T]</h1>
</section>

<section>
    <h1>Thank you!</h1>
</section>
